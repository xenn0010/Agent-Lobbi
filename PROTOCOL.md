# Agent Lobby Protocol v0.2.0

## 1. Overview

The Agent Lobby Protocol (ALP) defines the communication standards for agents within the Agent Lobby ecosystem. It enables agents to register, discover each other, exchange messages, invoke capabilities, and interact securely and reliably. The Lobby acts as a central router, service registry, and authority.

This document details the transport mechanisms, message structures, message types, communication flows, and security considerations.

## 2. Guiding Principles

*   **Interoperability:** Allow agents developed in different languages to communicate seamlessly.
*   **Extensibility:** Enable the protocol to evolve with new features and message types.
*   **Clarity:** Provide unambiguous definitions for message structures and interaction patterns.
*   **Security:** Ensure secure communication and authentication.
*   **Reliability:** Offer mechanisms for message tracking and error handling.

## 3. Glossary

*   **Agent:** An autonomous software entity capable of performing tasks, offering services (capabilities), and communicating via this protocol.
*   **Lobby:** The central server infrastructure that facilitates agent communication, registration, and discovery.
*   **Capability:** A well-defined service or function an agent can perform and advertise.
*   **Message:** A JSON-formatted unit of data exchanged between agents or between an agent and the Lobby.
*   **Transport:** The underlying communication channels (HTTP/S for registration, WebSocket (WSS) for real-time messaging).
*   **`agent_id`:** A unique identifier for an agent (e.g., UUID).
*   **`lobby_id`:** The unique identifier for the Lobby instance an agent is connected to (e.g., "global_lobby_main_prod").
*   **`message_id`:** A unique UUID for each message, used for tracking and idempotency.
*   **`conversation_id`:** A UUID used to group related messages in a multi-step interaction or request/response pattern.

## 4. Transport Layer

ALP utilizes two primary transport mechanisms:

### 4.1. HTTP/S (for Initial Registration & Authentication)

*   **Purpose:** Used by agents to perform an initial registration with the Lobby, submit credentials (like an API key), and receive an authentication token (`auth_token`).
*   **Endpoint:** The Lobby exposes a secure HTTPS endpoint (e.g., `https://lobby.example.com/api/v1/register`).
*   **Security:** Communication MUST occur over HTTPS (TLS).

### 4.2. WebSocket (WSS) (for Real-time Communication)

*   **Purpose:** Used for all subsequent real-time messaging between agents and the Lobby after successful registration and authentication.
*   **Endpoint:** The Lobby exposes a secure WebSocket endpoint (e.g., `wss://lobby.example.com/ws/connect`).
*   **Connection URI Format:** `wss://<lobby_host>:<lobby_port>/ws/connect?token=<auth_token>&agent_id=<agent_id>`
    *   `auth_token`: The token received during the HTTP registration phase.
    *   `agent_id`: The registered ID of the agent.
*   **Security:** Communication MUST occur over WSS (TLS).
*   **Subprotocols:** No specific WebSocket subprotocols are mandated by default, but implementations may negotiate them if needed for specific extensions.

## 5. Message Structure (Core)

All messages exchanged over WebSocket, regardless of type, MUST adhere to the following base JSON structure:

```json
{
  "message_id": "string (UUIDv4, unique for each message)",
  "protocol_version": "string (e.g., '0.2.0')",
  "sender_id": "string (agent_id of the sender, or lobby_id if from Lobby)",
  "receiver_id": "string (agent_id of the receiver, lobby_id, or special target like 'BROADCAST_ALL')",
  "message_type": "string (Defines the purpose and payload structure, see Section 7)",
  "payload": "object (Varies by message_type, can be empty: {})",
  "timestamp": "string (ISO 8601 UTC format, e.g., '2023-10-27T10:30:00Z')",
  "conversation_id": "string (UUIDv4, optional, for correlating messages)",
  "auth_token": "string (Deprecated for WebSocket messages; authentication is handled by token in WebSocket connection URI. May be used for specific Lobby HTTP API calls beyond initial registration if any.)",
  "metadata": "object (Optional, for custom headers or context, e.g., {'priority': 1, 'trace_id': 'xyz'})"
}
```

**Field Explanations:**

*   `message_id`: Generated by the sender. Crucial for idempotency and tracing.
*   `protocol_version`: Version of the ALP this message conforms to.
*   `sender_id`: Identifies the origin of the message.
*   `receiver_id`: Identifies the intended recipient.
    *   For agent-to-agent messages, this is the target `agent_id`.
    *   For messages to the lobby, this is the `lobby_id`.
    *   Special target IDs like `BROADCAST_ALL` can be used by the Lobby.
*   `message_type`: A string enum value indicating the nature of the message. Determines the expected structure of the `payload`.
*   `payload`: A JSON object containing data specific to the `message_type`.
*   `timestamp`: UTC timestamp marking when the message was created by the sender.
*   `conversation_id`: Used to link a sequence of messages, such as a request and its multiple responses, or an ongoing dialogue.
*   `auth_token`: Primarily for initial HTTP registration. For WebSocket messages, authentication is established at the connection level using the token in the URI.
*   `metadata`: An optional field for additional, non-core information.

## 6. Connection Lifecycle (WebSocket)

1.  **Agent Obtains `auth_token`:**
    *   Agent performs an initial HTTP/S POST request to the Lobby's registration endpoint (e.g., `/api/v1/register`) including its static API Key and desired `agent_id` and `agent_type`.
    *   Lobby validates the API Key, registers the agent (if `agent_id` is available or provisions one), and returns an `auth_token` and the `lobby_id`. (This is an alternative to the previous `lobby.register_agent()` followed by `REGISTER` message flow for a more typical client-server auth setup).
2.  **WebSocket Connection:**
    *   Agent initiates a WSS connection to the Lobby's WebSocket endpoint, providing the `auth_token` and its `agent_id` as query parameters in the URI.
    *   Example: `wss://lobby.example.com/ws/connect?token=xxxxxxx&agent_id=yyyyyyy`
3.  **Lobby Validates Connection:**
    *   Lobby validates the `auth_token` and `agent_id`.
    *   If valid, the WebSocket connection is established. The Lobby internally maps the WebSocket connection to the authenticated `agent_id`.
    *   If invalid, the Lobby rejects the WebSocket connection (e.g., HTTP 401/403 equivalent status code during handshake).
4.  **Post-Connection Registration (Optional but Recommended):**
    *   Once WebSocket is connected, the agent SHOULD send a `REGISTER_CLIENT` message to confirm its presence and provide its capabilities. This ensures the Lobby has the most up-to-date capability list for this active session.
    *   Lobby responds with `REGISTER_CLIENT_ACK`.
5.  **Message Exchange:** Agents and Lobby exchange messages conforming to the structures in this protocol.
6.  **Keep-Alive:**
    *   The Lobby and agents SHOULD use WebSocket PING/PONG frames to maintain connection liveness and detect unresponsive peers.
    *   The Lobby may define an inactivity timeout, after which it will send a PING. If no PONG is received, the connection may be closed.
    *   Agents should also send PINGs if no data is sent for a period and expect PONGs.
7.  **Graceful Shutdown (Agent Initiated):**
    *   Agent sends an `UNREGISTER_CLIENT` message.
    *   Agent closes the WebSocket connection.
8.  **Disconnection:**
    *   Can be initiated by agent, Lobby, or due to network issues.
    *   SDKs SHOULD implement automatic reconnection strategies, including re-establishing the WebSocket connection (using the existing `auth_token` if still valid) and re-sending `REGISTER_CLIENT`. If `auth_token` is rejected, the agent must re-perform the full HTTP registration.
    *   The Lobby updates the agent's status (e.g., to "offline") upon disconnection.

## 7. Standard Message Types & Payloads

### 7.1. Agent Registration and Session Management

#### 7.1.1. `REGISTER_CLIENT`
*   **Direction:** Agent -> Lobby
*   **Purpose:** Sent by an agent immediately after a successful WebSocket connection to announce its capabilities for this session.
*   **Payload:**
    ```json
    {
      "capabilities": [ /* Array of Capability objects (see Section 9) */ ],
      "agent_version": "string (e.g., '1.2.3', version of the agent software)",
      "sdk_version": "string (e.g., 'python-0.1.0', version of the SDK used)"
    }
    ```

#### 7.1.2. `REGISTER_CLIENT_ACK`
*   **Direction:** Lobby -> Agent
*   **Purpose:** Lobby acknowledges the agent's `REGISTER_CLIENT` message.
*   **Payload:**
    ```json
    {
      "status": "string ('success' or 'failure')",
      "lobby_id": "string (ID of the lobby instance)",
      "message": "string (Optional, details or error message)",
      "server_time_utc": "string (ISO 8601 UTC, Lobby's current time)",
      "session_id": "string (UUID, unique ID for this specific WebSocket session)"
    }
    ```

#### 7.1.3. `UNREGISTER_CLIENT`
*   **Direction:** Agent -> Lobby
*   **Purpose:** Agent informs the Lobby it is gracefully disconnecting.
*   **Payload:**
    ```json
    {
      "reason": "string (Optional, e.g., 'shutting_down', 'maintenance')"
    }
    ```
    *(Lobby does not necessarily send an ACK for this; closing the WebSocket is the confirmation.)*

### 7.2. Service Discovery

#### 7.2.1. `DISCOVER_CAPABILITIES`
*   **Direction:** Agent -> Lobby
*   **Purpose:** Agent queries the Lobby for agents offering specific capabilities.
*   **Payload:**
    ```json
    {
      "capability_filter": { // Filter criteria
        "name": "string (Optional, exact capability name, e.g., 'com.example.ImageAnalysis')",
        "version_match": "string (Optional, e.g., '1.x', '>=2.0.0', semantic versioning preferred)",
        "keywords": ["string"] // Optional, list of keywords
      },
      "max_results": "integer (Optional, default 10)"
    }
    ```

#### 7.2.2. `CAPABILITIES_FOUND`
*   **Direction:** Lobby -> Agent
*   **Purpose:** Lobby responds with a list of agents and their matching capabilities.
*   **Payload:**
    ```json
    {
      "query_ref": "string (mirrors conversation_id from DISCOVER_CAPABILITIES if provided)",
      "agents": [
        {
          "agent_id": "string",
          "agent_type": "string",
          "matching_capabilities": [ /* Array of full Capability objects (see Section 9) */ ],
          "last_seen_utc": "string (ISO 8601 UTC, if available)"
        }
      ]
    }
    ```

### 7.3. Agent-to-Agent Communication

#### 7.3.1. `DIRECT_MESSAGE`
*   **Direction:** Agent A -> Agent B (via Lobby)
*   **Purpose:** For general, unstructured or custom-structured messages between agents that don't fit the formal `INVOKE_CAPABILITY` pattern. Can be used for chat, notifications, or simpler data exchanges.
*   **Payload:**
    ```json
    {
      "content_type": "string (e.g., 'application/json', 'text/plain', 'custom/my-format')",
      "content": "any (JSON serializable data, string, or object, based on content_type)"
    }
    ```

#### 7.3.2. `INVOKE_CAPABILITY_REQUEST`
*   **Direction:** Agent A -> Agent B (via Lobby)
*   **Purpose:** Agent A requests Agent B to execute a specific advertised capability.
*   **Payload:**
    ```json
    {
      "capability_name": "string (Full name of the capability to invoke)",
      "capability_version": "string (Optional, specific version requested, e.g., '1.0.2')",
      "input_data": { /* Object matching the target capability's input_schema */ }
    }
    ```

#### 7.3.3. `INVOKE_CAPABILITY_RESPONSE`
*   **Direction:** Agent B -> Agent A (via Lobby)
*   **Purpose:** Agent B responds to an `INVOKE_CAPABILITY_REQUEST`.
*   **Payload:**
    ```json
    {
      "request_message_id": "string (message_id of the original INVOKE_CAPABILITY_REQUEST)",
      "status": "string ('success', 'error', 'in_progress', 'pending_async')",
      "output_data": { /* Object matching capability's output_schema if status is 'success' */ },
      "error_details": { /* Error object if status is 'error' (see Section 8.2) */ },
      "progress_info": { /* Optional, if status is 'in_progress' */
          "percentage": "integer (0-100)",
          "description": "string"
      }
    }
    ```
    *If `status` is `pending_async`, Agent B acknowledges the request and will send one or more `INVOKE_CAPABILITY_RESPONSE` messages later (potentially with `in_progress` and finally `success` or `error`) using the same `conversation_id`.

### 7.4. Lobby Communication

#### 7.4.1. `LOBBY_BROADCAST`
*   **Direction:** Lobby -> Agent(s) (receiver_id might be specific agent_id, a group, or `BROADCAST_ALL`)
*   **Purpose:** Lobby sends announcements, system events, or other information to agents.
*   **Payload:**
    ```json
    {
      "event_type": "string (e.g., 'system_maintenance', 'new_protocol_version', 'agent_joined_topic')",
      "data": "object (Details specific to the event_type)"
    }
    ```

#### 7.4.2. `PING`
*   **Direction:** Agent -> Lobby or Lobby -> Agent
*   **Purpose:** Used to check connection liveness if WebSocket PING/PONG frames are not sufficient or if application-level pings are desired.
*   **Payload:**
    ```json
    {
      "nonce": "string (Optional, a random string to be echoed in PONG)"
    }
    ```

#### 7.4.3. `PONG`
*   **Direction:** Agent -> Lobby or Lobby -> Agent
*   **Purpose:** Response to a `PING` message.
*   **Payload:**
    ```json
    {
      "nonce": "string (Echoes nonce from the PING message, if provided)"
    }
    ```

### 7.5. Error Reporting

#### 7.5.1. `PROTOCOL_ERROR`
*   **Direction:** Lobby -> Agent or Agent -> Lobby
*   **Purpose:** Indicates a problem related to the protocol itself (e.g., malformed message, invalid message type, authentication/authorization failure at protocol level).
*   **Payload:** (See Section 8.2 for Error Object structure)
    ```json
    {
      "error": { /* Error Object */ },
      "offending_message_id": "string (Optional, message_id of the message that caused the error)"
    }
    ```

## 8. Error Handling and Reporting

### 8.1. General Principles
*   **Fail Fast:** Errors should be reported as soon as they are detected.
*   **Clear Information:** Error messages should be informative enough for debugging.
*   **Standard Format:** Use the defined error structures.

### 8.2. Error Object Structure
When a message payload includes error details (e.g., in `PROTOCOL_ERROR` or `INVOKE_CAPABILITY_RESPONSE` with status "error"), it SHOULD use the following structure:

```json
{
  "code": "string (A unique error code, e.g., 'AUTH_FAILED', 'CAPABILITY_NOT_FOUND', 'INVALID_PAYLOAD')",
  "message": "string (Human-readable description of the error)",
  "details": "object (Optional, additional structured information about the error)",
  "retryable": "boolean (Optional, indicates if the operation might succeed on retry)"
}
```

### 8.3. Common Error Codes (Examples)

*   `AUTH_TOKEN_INVALID`, `AUTH_TOKEN_EXPIRED`, `API_KEY_INVALID`
*   `ACCESS_DENIED` (Authorization failure)
*   `MESSAGE_MALFORMED`, `INVALID_MESSAGE_TYPE`, `MISSING_REQUIRED_FIELD`
*   `RECEIVER_UNAVAILABLE`, `RECEIVER_NOT_FOUND`
*   `CAPABILITY_NOT_FOUND`, `CAPABILITY_VERSION_MISMATCH`
*   `INVALID_PAYLOAD_SCHEMA` (Payload doesn't match capability schema)
*   `RATE_LIMIT_EXCEEDED`
*   `INTERNAL_LOBBY_ERROR`, `INTERNAL_AGENT_ERROR`
*   `TIMEOUT_ERROR`

## 9. Capability Definition

Agents advertise their services as a list of "Capability" objects during registration (`REGISTER_CLIENT`).

```json
{
  "name": "string (Globally unique name, namespaced recommended, e.g., 'com.example.TranslationService.translateText')",
  "capability_version": "string (Semantic version, e.g., '1.0.2', '2.1.0-beta')",
  "description": "string (Human-readable description)",
  "input_schema": "object (JSON Schema defining the 'input_data' for INVOKE_CAPABILITY_REQUEST)",
  "output_schema": "object (JSON Schema defining the 'output_data' for successful INVOKE_CAPABILITY_RESPONSE)",
  "error_schema": "object (Optional, JSON Schema defining the 'error_details' for failed INVOKE_CAPABILITY_RESPONSE)",
  "keywords": ["string"], // Optional list of keywords for discovery
  "authorization_rules": { // Optional
    "type": "string (e.g., 'allow_list', 'requires_role', 'public')",
    "allowed_agent_ids": ["string"], // if type is 'allow_list'
    "required_roles": ["string"] // if type is 'requires_role'
  },
  "metadata": "object (Optional, custom attributes, e.g., {'cost_per_call': 0.01, 'sla': '99.9%'})"
}
```
*   **Schema Enforcement:** The Lobby MAY validate `INVOKE_CAPABILITY_REQUEST` input_data against the advertised `input_schema`. Agents MUST validate requests they receive.

## 10. Communication Flows

### 10.1. Agent Full Lifecycle
1.  **Initial HTTP Registration:**
    *   Agent (client SDK) -> Lobby: HTTP POST to `/api/v1/register` with API key, desired `agent_id`, `agent_type`.
    *   Lobby -> Agent: HTTP Response with `auth_token`, `lobby_id`, or error.
2.  **WebSocket Connection:**
    *   Agent -> Lobby: Initiates WSS connection to `/ws/connect?token=<auth_token>&agent_id=<agent_id>`.
    *   Lobby validates token/ID and establishes connection.
3.  **Client Registration:**
    *   Agent -> Lobby: `REGISTER_CLIENT` (capabilities, agent/sdk version).
    *   Lobby -> Agent: `REGISTER_CLIENT_ACK` (status, session_id).
4.  **Service Discovery:**
    *   Agent A -> Lobby: `DISCOVER_CAPABILITIES` (filter).
    *   Lobby -> Agent A: `CAPABILITIES_FOUND` (list of agents/capabilities).
5.  **Capability Invocation (Agent A -> Agent B):**
    *   Agent A -> Lobby: `INVOKE_CAPABILITY_REQUEST` (receiver_id=AgentB, capability_name, input_data). `conversation_id` set.
    *   Lobby authenticates A, authorizes for B's capability, routes to Agent B.
    *   Agent B -> Lobby: (Processes request) `INVOKE_CAPABILITY_RESPONSE` (receiver_id=AgentA, status, output_data/error_details). `conversation_id` matches.
    *   Lobby routes to Agent A.
6.  **Direct Message (Agent A -> Agent B):**
    *   Agent A -> Lobby: `DIRECT_MESSAGE` (receiver_id=AgentB, content).
    *   Lobby routes to Agent B. (Response is not mandated by this specific flow, can be another `DIRECT_MESSAGE`).
7.  **Lobby Broadcast:**
    *   Lobby -> Agent(s): `LOBBY_BROADCAST` (event_type, data).
8.  **Keep-Alive:** PING/PONG exchanges occur periodically.
9.  **Graceful Shutdown:**
    *   Agent -> Lobby: `UNREGISTER_CLIENT`.
    *   Agent closes WebSocket. Lobby updates status.

## 11. Security Considerations

*   **Transport Security:** All HTTP and WebSocket communication MUST use TLS (HTTPS/WSS).
*   **Authentication:**
    *   Initial: API Key based for HTTP registration.
    *   Session: Bearer `auth_token` for WebSocket connection establishment. Tokens should be time-limited and securely managed.
*   **Authorization:**
    *   Lobby enforces capability-level authorization based on advertised rules.
    *   Agents are responsible for finer-grained authorization within their own logic.
*   **Input Validation:** Agents and Lobby (where applicable) MUST validate message payloads against defined schemas to prevent injection and processing errors.
*   **Rate Limiting & Abuse Prevention:** The Lobby SHOULD implement mechanisms to prevent abuse (e.g., message rate limits per agent, connection limits).
*   **Data Privacy:** Payloads are routed by the Lobby but not typically inspected beyond what's necessary for routing and protocol enforcement. End-to-end encryption for sensitive `DIRECT_MESSAGE` or capability payloads can be implemented at the application layer by agents if needed, but is outside the scope of this core protocol version.

## 12. Extensibility & Versioning

*   **Protocol Versioning:** The `protocol_version` field in the base message structure allows for future evolution.
*   **Capability Versioning:** The `capability_version` field within the `Capability` definition allows individual services to evolve.
*   **Custom Message Types:** While this document defines standard types, the ecosystem can support custom `message_type` values for specific applications, provided senders and receivers agree on their structure. These should be namespaced to avoid collision (e.g., `X_MYAPP_CUSTOM_EVENT`).
*   **Metadata Field:** The `metadata` field in messages offers a flexible way to add custom information without altering core structures.

## 13. Future Considerations

*   Standardized topic-based publish/subscribe messaging.
*   More sophisticated presence and status management.
*   Binary payload support (e.g., via CBOR or Protocol Buffers alongside JSON).
*   End-to-end encryption negotiation. 